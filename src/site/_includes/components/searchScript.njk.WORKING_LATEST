<script src="https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', init, false);
    document.addEventListener('DOMContentLoaded', setCorrectShortcut, false);

    // Global variables
    let searchIndices = [];  // Will hold multiple search indices
    let searchData = {};     // Will hold our chunked data
    let totalChunks = 0;     // Total number of chunks in the index
    let loadedChunks = 0;    // Number of chunks loaded so far
    
    // Toggle search UI functions remain the same
    window.toggleSearch = function (e) {
        if (e && e.target.id === 'term') {
            return; // Don't close when clicking the search input
        }
        const searchContainer = document.getElementById('globalsearch');
        if (searchContainer.classList.contains('active')) {
            if (e && e.target === searchContainer) { // Only close if clicking outside
                searchContainer.classList.remove('active');
            }
        } else {
            searchContainer.classList.add('active');
            document.getElementById('term').focus();
        }
    }

    window.toggleTagSearch = function (evt) {
        const term = evt.textContent;
        if (term) {
            window.document.getElementById('term').value = term.trim();
            window.toggleSearch();
            window.search();
        }
    }

    // Loading animation remains the same
    const loadingSvg = `
    <svg width="100" height="100" viewBox="0 0 45 45" xmlns="http://www.w3.org/2000/svg" stroke="#fff">
      <!-- SVG loading animation code unchanged -->
    </svg>`;

    // Debounce function remains the same
    function debounce(func, wait, immediate) {
        var timeout;
        return function () {
            var context = this,
                args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) 
                    func.apply(context, args);
                };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) 
                func.apply(context, args);
            };
    }

    function setCorrectShortcut() {
        if (navigator.platform.toUpperCase().indexOf('MAC') >= 0) {
            document.querySelectorAll(".search-keys").forEach(x => x.innerHTML = "âŒ˜ + K");
        }
    }

    // Create an optimized index for a chunk of data
    function createIndex(posts) {
        const encoder = (str) => str
            .toLowerCase()
            .split(/([^a-z]|[^\x00-\x7F])/);
            
        const contentIndex = new FlexSearch.Document({
            cache: true,
            charset: "latin:extra",
            optimize: true,
            index: [
                {
                    field: "content",
                    tokenize: "reverse",
                    encode: encoder,
                    resolution: 9
                },
                {
                    field: "title",
                    tokenize: "forward",
                    encode: encoder,
                    resolution: 9
                }
            ]
        });

        posts.forEach((p, idx) => {
            contentIndex.add({
                id: idx, 
                title: p.title, 
                content: p.content
            });
        });
        return contentIndex;
    }

    async function init() {
        try {
            let docs = await(await fetch('/searchIndex.json?v={{meta.buildDate|isoDate}}')).json();
            let index = createIndex(docs);
            window.docs = docs;
            window.index = index;

            setupKeyboardNavigation();
            checkForUrlSearchParam();
            handleSearchHighlight(); // Add this line
        } catch (error) {
            console.error("Error initializing search:", error);
            document.querySelector('#search-results').innerHTML = 
                `<p>Search index failed to load. Please try refreshing the page.</p>`;
        }
    }

    // Add this function
    function handleSearchHighlight() {
        const params = new URLSearchParams(window.location.search);
        const term = params.get('term');
        if (!term) return;

        // Increase initial delay and add a loading check
        const startHighlight = () => {
            const content = document.querySelector('.content');
            if (!content || !content.offsetHeight) {
                // Content not fully loaded yet, retry in 500ms
                setTimeout(startHighlight, 500);
                return;
            }

            // Once content is loaded, add highlights
            const highlights = [];
            const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT);
            const textNodes = [];
            
            while (walker.nextNode()) textNodes.push(walker.currentNode);
            
            textNodes.forEach(node => {
                if (node.textContent.match(regex)) {
                    const span = document.createElement('span');
                    span.className = 'temp-highlight';
                    span.innerHTML = node.textContent.replace(regex, '<span class="temp-highlight">$1</span>');
                    node.parentNode.replaceChild(span, node);
                    highlights.push(span);
                }
            });

            if (highlights.length > 0) {
                // Scroll to first match
                highlights[0].scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center'
                });

                // Start timer only after scroll completes
                setTimeout(() => {
                    window.scrollBy(0, -100);
                    
                    const removeHighlights = () => {
                        highlights.forEach(el => {
                            el.classList.add('fade-out');
                            setTimeout(() => {
                                if (el.parentNode) {
                                    el.outerHTML = el.innerHTML;
                                }
                            }, 500);
                        });
                    };

                    // Add event listeners for early removal
                    window.addEventListener('scroll', removeHighlights, { once: true });
                    document.addEventListener('click', removeHighlights, { once: true });

                    // Set longer timeout for automatic removal
                    setTimeout(removeHighlights, 15000); // Increased to 15 seconds
                }, 1000); // Wait 1s after scroll
            }
        };

        // Add styles first
        const style = document.createElement('style');
        style.textContent = `
            .temp-highlight {
                background-color: var(--text-accent);
                color: var(--background-primary);
            }
            .temp-highlight.fade-out {
                background-color: transparent !important;
                color: inherit !important;
                transition: all 0.5s ease-out;
            }
        `;
        document.head.appendChild(style);

        // Start the highlight process
        setTimeout(startHighlight, 1000);

        // Clean URL
        window.history.replaceState({}, '', window.location.pathname);
    }

    function setupKeyboardNavigation() {
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                toggleSearch();
            }
            if (e.key === 'Escape') {
                document.getElementById('globalsearch').classList.remove('active');
            }

            // Navigate search results with arrow keys
            if (document.getElementById('globalsearch').classList.contains('active')) {
                // Arrow navigation code unchanged
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    let active = document.querySelector('.searchresult.active');
                    if (active) {
                        active.classList.remove('active');
                        if (active.nextElementSibling) {
                            active.nextElementSibling.classList.add('active');
                        } else {
                            document.querySelector('.searchresult').classList.add('active');
                        }
                    } else {
                        document.querySelector('.searchresult').classList.add('active');
                    }

                    let currentActive = document.querySelector('.searchresult.active');
                    if (currentActive) {
                        currentActive.scrollIntoView({behavior: 'smooth', block: 'nearest', inline: 'start'});
                    }
                }
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    let active = document.querySelector('.searchresult.active');
                    if (active) {
                        active.classList.remove('active');
                        if (active.previousElementSibling) {
                            active.previousElementSibling.classList.add('active');
                        } else {
                            document.querySelectorAll('.searchresult').forEach((el) => {
                                if (!el.nextElementSibling) {
                                    el.classList.add('active');
                                }
                            });
                        }
                    } else {
                        document.querySelectorAll('.searchresult').forEach((el) => {
                            if (el.nextElementSibling) {
                                el.classList.add('active');
                            }
                        });
                    }

                    let currentActive = document.querySelector('.searchresult.active');
                    if (currentActive) {
                        currentActive.scrollIntoView({behavior: 'smooth', block: 'nearest', inline: 'start'});
                    }
                }
                if (e.key === 'Enter') {
                    e.preventDefault();
                    let active = document.querySelector('.searchresult.active');
                    if (active) {
                        window.location.href = active.querySelector("a").href;
                    }
                }
            }
        });
    }
    
    function checkForUrlSearchParam() {
        const params = new URL(location.href).searchParams;
        if (params.get('q')) {
            field = document.querySelector('#term');
            field.setAttribute('value', params.get('q'));
            toggleSearch();
            search();
        }
    }

    // Set up debounced search
    window.lastSearch = '';
    let field = document.querySelector('#term');
    let resultsDiv = document.querySelector('#search-results');
    const debouncedSearch = debounce(search, 200, false);
    
    field.addEventListener('keydown', (e) => {
        if (e.key !== 'ArrowDown' && e.key !== 'ArrowUp') {
            debouncedSearch();
        }
    });

    // Search across all loaded chunks
    async function search() {
        let searchTerm = field.value.trim();
        if (!searchTerm) return;
        if (searchTerm === window.lastSearch) return;
        
        window.lastSearch = searchTerm;
        resultsDiv.innerHTML = loadingSvg;

        let results = performOfflineSearch(searchTerm);
        let resultsHTML = '<div style="max-width:100%;">';
        
        if (!results.length) {
            let resultParagraph = document.createElement("p");
            resultParagraph.innerText = `No results for "${searchTerm}"`;
            resultsDiv.innerHTML = '';
            resultsDiv.appendChild(resultParagraph);
            return;
        }

        results.forEach(r => {
            resultsHTML += `<div class="searchresult">
                <a class="search-link" href="${r.url}?term=${encodeURIComponent(searchTerm)}">${r.title}</a>
                <div onclick="window.location='${r.url}?term=${encodeURIComponent(searchTerm)}'">
                    ${getSearchContext(r.content, searchTerm)}
                </div>
            </div>`;
        });
        resultsHTML += '</div>';
        resultsDiv.innerHTML = resultsHTML;
    }

    function getSearchContext(content, searchTerm) {
        const plainText = content.replace(/<[^>]*>/g, '');
        const termPos = plainText.toLowerCase().indexOf(searchTerm.toLowerCase());
        
        // Show text around the match with highlighting
        let start = Math.max(0, termPos - 100);
        let end = Math.min(plainText.length, start + 300);
        let snippet = (start > 0 ? '...' : '') + 
                     plainText.substring(start, end) + 
                     (end < plainText.length ? '...' : '');

        // Highlight the search term
        const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
        return snippet.replace(regex, '<strong>$1</strong>');
    }

    function performOfflineSearch(searchQuery) {
        let data = window.docs;

        let searchResults = window.index.search(searchQuery, [
            {field: "title", limit: 20},  // Increased from 10
            {field: "content", limit: 100}  // Increased from 50
        ]);

        const getByField = (field) => {
            const results = searchResults.filter((x) => x.field === field)
            if (results.length === 0) return []
            return [...results[0].result]
        }

        const allIds = new Set([
            ...getByField("title"),
            ...getByField("content")
        ])

        return [...allIds].map((id) => data[id]);
    }

    function performSearch(searchTerm) {
        // Check if it's a tag search
        const isTagSearch = searchTerm[0] === "#" && searchTerm.length > 1;
        const searchField = isTagSearch ? "tags" : ["title", "content"];
        const actualTerm = isTagSearch ? searchTerm.substring(1) : searchTerm;
        
        // Array to collect results from all indices
        let allResults = [];
        
        // Search across all loaded indices
        searchIndices.forEach(indexObj => {
            let indexResults;
            
            if (isTagSearch) {
                indexResults = indexObj.index.search(actualTerm, {
                    field: "tags",
                    limit: 20
                });
            } else {
                indexResults = indexObj.index.search(actualTerm, {
                    field: "title",
                    limit: 10,
                    boost: 2
                });
                
                // Also search content
                const contentResults = indexObj.index.search(actualTerm, {
                    field: "content",
                    limit: 20
                });
                
                // Combine results
                indexResults = [...indexResults, ...contentResults];
            }
            
            // Process results
            indexResults.forEach(result => {
                // Convert index-specific ID to global ID for this chunk
                const globalId = `${indexObj.id}-${result.id}`;
                const item = searchData[globalId];
                if (item) {
                    // Avoid duplicates
                    if (!allResults.some(r => r.url === item.url)) {
                        allResults.push({
                            ...item,
                            // Store the match details for potential ranking
                            matchField: result.field,
                            score: result.score
                        });
                    }
                }
            });
        });
        
        // Sort results - title matches first, then by score
        allResults.sort((a, b) => {
            // First prioritize title matches
            if (a.matchField === 'title' && b.matchField !== 'title') return -1;
            if (a.matchField !== 'title' && b.matchField === 'title') return 1;
            
            // Then by score
            return b.score - a.score;
        });
        
        // Limit to top 20 results
        return allResults.slice(0, 20);
    }
    
    function displayResults(results, searchTerm) {
        if (!results.length) {
            let resultParagraph = document.createElement("p");
            resultParagraph.innerHTML = `No results for "${searchTerm}"<br>
                <small>(${loadedChunks}/${totalChunks} index chunks loaded)</small>`;
            resultsDiv.innerHTML = '';
            resultsDiv.appendChild(resultParagraph);
            return;
        }
        
        let resultsHTML = '<div style="max-width:100%;">';
        
        // Display loading status if not all chunks are loaded
        if (loadedChunks < totalChunks) {
            resultsHTML += `<p class="search-status"><small>Showing results from ${loadedChunks}/${totalChunks} chunks</small></p>`;
        }
        
        // Process and display each result
        results.forEach(r => {
            // Prepare content snippet with highlighting
            let snippet = prepareSnippet(r.content, searchTerm);
            
            if(r.tags && r.tags.length > 0){
                resultsHTML += `<div class="searchresult">
                    <a class="search-link" href="${r.url}">${r.title}</a>
                    <div onclick="window.location='${r.url}'>
                        <div class="header-meta">
                            <div class="header-tags">
                                ${r.tags.map(tag=>'<a class="tag" href="JavaScript:Void(0);" onclick="window.toggleTagSearch(this)">#'+tag+'</a>').join("")}
                            </div>
                        </div>
                        ${snippet}
                    </div>
                </div>`;
            } else {
                resultsHTML += `<div class="searchresult">
                    <a class="search-link" href="${r.url}">${r.title}</a>
                    <div onclick="window.location='${r.url}'>
                        ${snippet}
                    </div>
                </div>`;
            }
        });
        
        resultsHTML += '</div>';
        resultsDiv.innerHTML = resultsHTML;
    }
    
    function prepareSnippet(content, searchTerm) {
        // Remove HTML tags
        const plainText = content.replace(/<[^>]*>/g, '');
        
        // Find position of the search term
        const termPos = plainText.toLowerCase().indexOf(searchTerm.toLowerCase());
        
        // If term not found in content, just return the beginning
        if (termPos === -1) {
            return truncate(plainText, 300);
        }
        
        // Calculate snippet start position, aiming to center the search term
        let start = Math.max(0, termPos - 100);
        
        // If we're not starting from the beginning, add ellipsis
        let snippet = (start > 0 ? '...' : '') + plainText.substring(start);
        
        // Truncate to reasonable length
        snippet = truncate(snippet, 300);
        
        // Basic highlighting by wrapping in strong tags
        // This is a simple approach - for better highlighting, consider a dedicated library
        const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
        snippet = snippet.replace(regex, '<strong>$1</strong>');
        
        return snippet;
    }

    function truncate(str, size) {
        if (!str) return '';
        //first, remove HTML
        str = str.replace(/<[^>]*>/g, '');
        if (str.length < size) 
            return str;
        return str.substring(0, size - 3) + '...';
    }
</script>
