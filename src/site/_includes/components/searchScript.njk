// ------ searchscript.njk ------

<script src="https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', init, false);
    document.addEventListener('DOMContentLoaded', setCorrectShortcut, false);

    // Global variables
    let searchIndices = [];  // Will hold multiple search indices
    let searchData = {};     // Will hold our chunked data
    let totalChunks = 0;     // Total number of chunks in the index
    let loadedChunks = 0;    // Number of chunks loaded so far
    
    // Toggle search UI functions remain the same
    window.toggleSearch = function () {
        if (document.getElementById('globalsearch').classList.contains('active')) {
            document.getElementById('globalsearch').classList.remove('active');
        } else {
            document.getElementById('globalsearch').classList.add('active');
            document.getElementById('term').focus();
        }
    }

    window.toggleTagSearch = function (evt) {
        const term = evt.textContent;
        if (term) {
            window.document.getElementById('term').value = term.trim();
            window.toggleSearch();
            window.search();
        }
    }

    // Loading animation remains the same
    const loadingSvg = `
    <svg width="100" height="100" viewBox="0 0 45 45" xmlns="http://www.w3.org/2000/svg" stroke="#fff">
      <!-- SVG loading animation code unchanged -->
    </svg>`;

    // Debounce function remains the same
    function debounce(func, wait, immediate) {
        var timeout;
        return function () {
            var context = this,
                args = arguments;
            var later = function () {
                timeout = null;
                if (!immediate) 
                    func.apply(context, args);
                };
            var callNow = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
            if (callNow) 
                func.apply(context, args);
            };
    }

    function setCorrectShortcut() {
        if (navigator.platform.toUpperCase().indexOf('MAC') >= 0) {
            document.querySelectorAll(".search-keys").forEach(x => x.innerHTML = "âŒ˜ + K");
        }
    }

    // Create an optimized index for a chunk of data
    function createIndex(posts) {
        const encoder = (str) => str
            .toLowerCase()
            .split(/([^a-z]|[^\x00-\x7F])/);
            
        const contentIndex = new FlexSearch.Document({
            cache: true,
            charset: "latin:extra",
            optimize: true,
            index: [
                {
                    field: "content",
                    tokenize: "reverse",
                    encode: encoder,
                    resolution: 9
                },
                {
                    field: "title",
                    tokenize: "forward",
                    encode: encoder,
                    resolution: 9
                },
                {
                    field: "tags",
                    tokenize: "forward",
                    encode: encoder,
                    resolution: 9
                }
            ]
        });

        posts.forEach((p, idx) => {
            contentIndex.add({
                id: idx, 
                title: p.title, 
                content: p.content, 
                tags: p.tags
            });
        });
        return contentIndex;
    }

    async function init() {
        const searchIndexDate = '{{meta.buildDate|isoDate}}';
        let shouldFetch = true;
        
        try {
            if(localStorage.getItem("searchIndex")) {
                let {date, docs} = JSON.parse(localStorage.getItem('searchIndex'));
                if(date === searchIndexDate){
                    shouldFetch = false;
                    let index = createIndex(docs);
                    window.docs = docs;
                    window.index = index;
                }        
            }
            
            if(shouldFetch){
                let docs = await(await fetch('/searchIndex.json?v={{meta.buildDate|isoDate}}')).json();
                let index = createIndex(docs);
                localStorage.setItem("searchIndex", JSON.stringify({
                    date: searchIndexDate, 
                    docs
                }));
                window.docs = docs;
                window.index = index;
            }

            // Setup keyboard shortcuts and URL parameter check
            setupKeyboardNavigation();
            checkForUrlSearchParam();
        } catch (error) {
            console.error("Error initializing search:", error);
            document.querySelector('#search-results').innerHTML = 
                `<p>Search index failed to load. Please try refreshing the page.</p>`;
        }
    }
    
    function updateLoadingStatus(loaded, total) {
        const statusElement = document.getElementById('search-loading-status');
        if (!statusElement) return;
        
        const percent = Math.round((loaded / total) * 100);
        statusElement.textContent = `Loading search index: ${percent}% (${loaded}/${total} chunks)`;
        statusElement.style.display = loaded < total ? 'block' : 'none';
    }
    
    async function loadSearchChunk(chunkId) {
        try {
            // Load the chunk from the server
            const chunkData = await (await fetch(`/searchIndex-${chunkId}.json?v={{meta.buildDate|isoDate}}`)).json();
            
            // Add the data to our searchData object
            chunkData.forEach((item, index) => {
                const globalId = `${chunkId}-${index}`;
                searchData[globalId] = item;
            });
            
            // Create an index for this chunk
            const index = createIndex(chunkData, chunkId);
            searchIndices.push({
                id: chunkId,
                index: index,
                data: chunkData
            });
            
            // Update our loading progress
            loadedChunks++;
            updateLoadingStatus(loadedChunks, totalChunks);
            
            return true;
        } catch (error) {
            console.error(`Error loading chunk ${chunkId}:`, error);
            return false;
        }
    }
    
    async function loadRemainingChunksInBackground() {
        // Load remaining chunks sequentially to avoid overwhelming the browser
        for (let i = 1; i < totalChunks; i++) {
            await loadSearchChunk(i);
            // Small delay to let the browser breathe
            await new Promise(resolve => setTimeout(resolve, 300));
        }
    }
    
    function setupKeyboardNavigation() {
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                toggleSearch();
            }
            if (e.key === 'Escape') {
                document.getElementById('globalsearch').classList.remove('active');
            }

            // Navigate search results with arrow keys
            if (document.getElementById('globalsearch').classList.contains('active')) {
                // Arrow navigation code unchanged
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    let active = document.querySelector('.searchresult.active');
                    if (active) {
                        active.classList.remove('active');
                        if (active.nextElementSibling) {
                            active.nextElementSibling.classList.add('active');
                        } else {
                            document.querySelector('.searchresult').classList.add('active');
                        }
                    } else {
                        document.querySelector('.searchresult').classList.add('active');
                    }

                    let currentActive = document.querySelector('.searchresult.active');
                    if (currentActive) {
                        currentActive.scrollIntoView({behavior: 'smooth', block: 'nearest', inline: 'start'});
                    }
                }
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    let active = document.querySelector('.searchresult.active');
                    if (active) {
                        active.classList.remove('active');
                        if (active.previousElementSibling) {
                            active.previousElementSibling.classList.add('active');
                        } else {
                            document.querySelectorAll('.searchresult').forEach((el) => {
                                if (!el.nextElementSibling) {
                                    el.classList.add('active');
                                }
                            });
                        }
                    } else {
                        document.querySelectorAll('.searchresult').forEach((el) => {
                            if (el.nextElementSibling) {
                                el.classList.add('active');
                            }
                        });
                    }

                    let currentActive = document.querySelector('.searchresult.active');
                    if (currentActive) {
                        currentActive.scrollIntoView({behavior: 'smooth', block: 'nearest', inline: 'start'});
                    }
                }
                if (e.key === 'Enter') {
                    e.preventDefault();
                    let active = document.querySelector('.searchresult.active');
                    if (active) {
                        window.location.href = active.querySelector("a").href;
                    }
                }
            }
        });
    }
    
    function checkForUrlSearchParam() {
        const params = new URL(location.href).searchParams;
        if (params.get('q')) {
            field = document.querySelector('#term');
            field.setAttribute('value', params.get('q'));
            toggleSearch();
            search();
        }
    }

    // Set up debounced search
    window.lastSearch = '';
    let field = document.querySelector('#term');
    let resultsDiv = document.querySelector('#search-results');
    const debouncedSearch = debounce(search, 200, false);
    
    field.addEventListener('keydown', (e) => {
        if (e.key !== 'ArrowDown' && e.key !== 'ArrowUp') {
            debouncedSearch();
        }
    });

    // Search across all loaded chunks
    async function search() {
        let searchTerm = field.value.trim();
        if (!searchTerm) return;
        if (searchTerm === window.lastSearch) return;
        
        window.lastSearch = searchTerm;
        resultsDiv.innerHTML = loadingSvg;
        
        // Check if we need to prioritize loading a specific chunk for this search
        if (searchIndices.length < totalChunks) {
            // We could add logic here to prioritize loading certain chunks based on the search term
            // For now, we'll just continue with what we have loaded
        }
        
        // Execute the search
        let results = performSearch(searchTerm);
        displayResults(results, searchTerm);
    }
    
    function performSearch(searchTerm) {
        // Check if it's a tag search
        const isTagSearch = searchTerm[0] === "#" && searchTerm.length > 1;
        const searchField = isTagSearch ? "tags" : ["title", "content"];
        const actualTerm = isTagSearch ? searchTerm.substring(1) : searchTerm;
        
        // Array to collect results from all indices
        let allResults = [];
        
        // Search across all loaded indices
        searchIndices.forEach(indexObj => {
            let indexResults;
            
            if (isTagSearch) {
                indexResults = indexObj.index.search(actualTerm, {
                    field: "tags",
                    limit: 20
                });
            } else {
                indexResults = indexObj.index.search(actualTerm, {
                    field: "title",
                    limit: 10,
                    boost: 2
                });
                
                // Also search content
                const contentResults = indexObj.index.search(actualTerm, {
                    field: "content",
                    limit: 20
                });
                
                // Combine results
                indexResults = [...indexResults, ...contentResults];
            }
            
            // Process results
            indexResults.forEach(result => {
                // Convert index-specific ID to global ID for this chunk
                const globalId = `${indexObj.id}-${result.id}`;
                const item = searchData[globalId];
                if (item) {
                    // Avoid duplicates
                    if (!allResults.some(r => r.url === item.url)) {
                        allResults.push({
                            ...item,
                            // Store the match details for potential ranking
                            matchField: result.field,
                            score: result.score
                        });
                    }
                }
            });
        });
        
        // Sort results - title matches first, then by score
        allResults.sort((a, b) => {
            // First prioritize title matches
            if (a.matchField === 'title' && b.matchField !== 'title') return -1;
            if (a.matchField !== 'title' && b.matchField === 'title') return 1;
            
            // Then by score
            return b.score - a.score;
        });
        
        // Limit to top 20 results
        return allResults.slice(0, 20);
    }
    
    function displayResults(results, searchTerm) {
        if (!results.length) {
            let resultParagraph = document.createElement("p");
            resultParagraph.innerHTML = `No results for "${searchTerm}"<br>
                <small>(${loadedChunks}/${totalChunks} index chunks loaded)</small>`;
            resultsDiv.innerHTML = '';
            resultsDiv.appendChild(resultParagraph);
            return;
        }
        
        let resultsHTML = '<div style="max-width:100%;">';
        
        // Display loading status if not all chunks are loaded
        if (loadedChunks < totalChunks) {
            resultsHTML += `<p class="search-status"><small>Showing results from ${loadedChunks}/${totalChunks} chunks</small></p>`;
        }
        
        // Process and display each result
        results.forEach(r => {
            // Prepare content snippet with highlighting
            let snippet = prepareSnippet(r.content, searchTerm);
            
            if(r.tags && r.tags.length > 0){
                resultsHTML += `<div class="searchresult">
                    <a class="search-link" href="${r.url}">${r.title}</a>
                    <div onclick="window.location='${r.url}'>
                        <div class="header-meta">
                            <div class="header-tags">
                                ${r.tags.map(tag=>'<a class="tag" href="JavaScript:Void(0);" onclick="window.toggleTagSearch(this)">#'+tag+'</a>').join("")}
                            </div>
                        </div>
                        ${snippet}
                    </div>
                </div>`;
            } else {
                resultsHTML += `<div class="searchresult">
                    <a class="search-link" href="${r.url}">${r.title}</a>
                    <div onclick="window.location='${r.url}'>
                        ${snippet}
                    </div>
                </div>`;
            }
        });
        
        resultsHTML += '</div>';
        resultsDiv.innerHTML = resultsHTML;
    }
    
    function prepareSnippet(content, searchTerm) {
        // Remove HTML tags
        const plainText = content.replace(/<[^>]*>/g, '');
        
        // Find position of the search term
        const termPos = plainText.toLowerCase().indexOf(searchTerm.toLowerCase());
        
        // If term not found in content, just return the beginning
        if (termPos === -1) {
            return truncate(plainText, 300);
        }
        
        // Calculate snippet start position, aiming to center the search term
        let start = Math.max(0, termPos - 100);
        
        // If we're not starting from the beginning, add ellipsis
        let snippet = (start > 0 ? '...' : '') + plainText.substring(start);
        
        // Truncate to reasonable length
        snippet = truncate(snippet, 300);
        
        // Basic highlighting by wrapping in strong tags
        // This is a simple approach - for better highlighting, consider a dedicated library
        const regex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
        snippet = snippet.replace(regex, '<strong>$1</strong>');
        
        return snippet;
    }

    function truncate(str, size) {
        if (!str) return '';
        //first, remove HTML
        str = str.replace(/<[^>]*>/g, '');
        if (str.length < size) 
            return str;
        return str.substring(0, size - 3) + '...';
    }
</script>
